---
title: "Development records notebook"
author: "Pedro Ivo Guimarães"
description: LambdaPCR development archiving notebook
output: html_notebook
---

# February 

## Packages and global options

```{r packages, message=FALSE, warning=FALSE}
library(tidyverse)
# library(Biostrings)
library(devtools)
library(stringr)
```

## 02-26-18

### Importing sequences

The most basic function of this app is importing a sequence file on FASTA format. The imported file can either be the *template* sequence or the *target* sequence. The target sequence is the DNA sequence of the gene of interest that will be inserted into the template sequence. We can create a basic function to import a DNA sequence with two derived functions, one for each type of input:

```{r read-sequence-fun}
read_sequence <- function(file, ...) {
  raw <- as_data_frame(read_file(file))
  
  df <-raw %>%
    separate_rows(value, sep = '\n>') %>%
    separate(value, into = c('header', 'seq'), sep = '\n', extra = 'merge') %>%
    mutate(
      seq = str_replace_all(seq, '\n', ''),
      header = str_replace(header, '>', ''),
      length = nchar(seq)
    )
}

template <- read_sequence("../data/puc19.fasta")
target <- read_sequence("../data/GFP sequence.fasta")
```

## 02-28-18

### Updating `read_sequence` function

An useful functionality of `read_sequence` would be simplifying the sequence header information by allowing the user provide a `header_structure` vector — containing the naming scheme of the sequence header — and `id_field` — the field that will be used as the seq id:

```{r fun-read-sequence-update}
read_sequence <- function(file, id_field = NULL, separator = NULL) {
  raw <- as_data_frame(read_file(file))
  
  df <- raw %>%
    separate_rows(value, sep = '\n>') %>%
    separate(value, into = c('header', 'seq'), sep = '\n', extra = 'merge') %>%
    mutate(
      seq = str_replace_all(seq, '\n', ''),
      header = str_replace(header, '>', ''),
      length = nchar(seq)
    )
  
  #Checking if optional parameters were passed
  if(is.null(id_field)) {
    id_field <- 'id'
  }
  if(is.null(separator)) {
    separator <- '\\|'
  }
  
  #Creating sequence id from seq header
  df <- df %>%
    separate(header, into = id_field, extra = 'drop', sep = separator)
}

template <- read_sequence("../data/puc19.fasta")
target <- read_sequence("../data/GFP sequence.fasta")
```

# March

## 03-01-18

### Update `read_sequence` to add `type` tag to sequences

The `read_sequence` function does not differentiate if the sequence object is a template or a target gene object, so I'll update it again to import the DNA sequences and add a tag `template` or `target`:

```{r fun-read-sequence-update-2}
read_sequence <- function(file, input_type, id_field = NULL, separator = NULL) {
  raw <- as_data_frame(read_file(file))
  
  df <- raw %>%
    separate_rows(value, sep = '\n>') %>%
    separate(value, into = c('header', 'seq'), sep = '\n', extra = 'merge') %>%
    mutate(
      type = input_type,
      seq = str_replace_all(seq, '\n', ''),
      header = str_replace(header, '>', ''),
      length = nchar(seq)
    )
  
  #Checking if optional parameters were passed
  if(is.null(id_field)) {
    id_field <- 'id'
  }
  if(is.null(separator)) {
    separator <- '\\|'
  }
  
  #Creating sequence id from seq header
  df <- df %>%
    separate(header, into = id_field, remove = F, extra = 'drop', sep = separator)
}

template <- read_sequence("../data/puc19.fasta", input_type = 'template')
target <- read_sequence("../data/GFP sequence.fasta", input_type = 'target')
```

### Design primers for gene insertion

#### Extract template and target gene sequence overlaps for primer design
The simplest design case for Lambda PCR is the insertion of the target gene in a defined location in the destination plasmid. The first thing we need to do is write a function that will collect the extract the *n*-length flanking regions to the left and right of the insertion site and store as the template-overlaping tails of the primers. 

As a starting condition, let's extract $n = 15$ bps around the insertion site:

```{r template-overlap-extraction}
# insertion_coordinate <- 1500
# ins_flank_length <- 20
# target_primer_length <- 15

#Functions to extract flanking sequences from insertion site:
get_overlaps <- function(seq_object, position=NULL, length=NULL) {
  #Initialize empty overlap object
  overlaps <- tibble(
    id = character(),
    type = character(),
    origin = character(),
    seq = character()
  )
  
  #Checking what type of object was passed to function:
  if(seq_object$type == 'template') {
    #Using default overlap length of 20 if not provided:
    overlap_length <- ifelse(is.null(length), 20, length)
    #Extracting overlaps
    overlap_left <- substr(seq_object$seq, (position-overlap_length), position)
    overlap_right <- substr(seq_object$seq, (position+1), (overlap_length+position+1))
    #Populating overlap object:
    overlaps <- overlaps %>% 
      add_row(id = 'left', type = 'overlap', origin = 'template', seq = overlap_left) %>%
      add_row(id = 'right', type = 'overlap', origin = 'template', seq = overlap_right)
  } else {
    #Using default overlap length of 20 if not provided:
    overlap_length <- ifelse(is.null(length), 15, length)
    #Extracting overlaps
    overlap_left <- substr(seq_object$seq, 1, overlap_length)
    overlap_right <- substr(seq_object$seq, seq_object$length-overlap_length, seq_object$length)
    #Populating overlap object:
    overlaps <- overlaps %>% 
      add_row(id = 'left', type = 'overlap', origin = 'target', seq = overlap_left) %>%
      add_row(id = 'right', type = 'overlap', origin = 'target', seq = overlap_right)
  }
}

overlaps_template <- get_overlaps(template, position = 1500)
overlaps_target <- get_overlaps(target)
```

#### Complement and reverse complement functions: 

```{r fun-seq-convertion}
complement <- function(sequence) {
  seq <- toupper(sequence)
  complement <- chartr('ATCG', 'TAGC', seq)
}

reverse_complement <- function(sequence) {
  complement <- complement(sequence)
  revcomp <- stringi::stri_reverse(complement)
}

```

#### Correct primer orientations

Primer design for LambdaPCR is tricky because there are special rules that need to be followed regarding the primer tails. I had to use colored markers to understand what to do:

```{r primer-design-guide-img}
knitr::include_graphics("~/Downloads/Lambapcr_primer_rules.jpg")
knitr::include_graphics("~/Desktop/lambdapcr_overview.png")
```

So, in order to design the primers for the first PCR of LambdaPCR, we have to use the following rules:

- Forward primer: template left overlap + target left overlap, 5'-3' orientation
- Reverser primer: complement of target right overlap + complement of template right overlap,  5'-3' orientation

Now that we have the overlaps for both the template and the target sequences, we can create our first LambdaPCR primer pair:

```{r fun-create-primers}
create_primers <- function(overlaps_target, overlaps_template) {
  overlaps <- bind_rows(overlaps_target, overlaps_template)
  
  primers <- overlaps %>%
    spread(origin, seq) %>%
    select(-type) %>%
    mutate(
      seq = case_when(
        id == 'left' ~ paste(tolower(template), 
                             target, 
                             sep = ''),
        id == 'right' ~ paste(tolower(reverse_complement(template)), 
                              reverse_complement(target), 
                              sep = ''
                              )
      )
    ) %>%
    mutate(id = case_when(
      id == 'left' ~ gsub('left', 'forward', id),
      id == 'right' ~ gsub('right', 'reverse', id)
    )) %>%
    mutate(type = 'primer') %>%
    select(-target, -template)
}

primers <- create_primers(overlaps_target, overlaps_template)
```

## 03/08/18

### `lambdaPrimer` flowchart

```{r diagrammer-test}
library(DiagrammeR)

grViz("
  digraph lambdaPrimeR_dataflow {
    rankdir='LR';
    # splines='ortho';
    #internal object nodes:
    node [shape = circle]
    input; overlaps; primers; score
    
    #Input and output nodes 
    node [shape = box]
    target; template; ins_position; report

    #Function nodes:
    node [shape = plaintext]
    read_sequences; get_overlaps; create_primer; melt_temp;
    hairpin_prob; primer_score; rank_primers; mutate_primer;
    report_best_primers
    
    #Edges:
    target -> read_sequences; template -> read_sequences; 
    read_sequences -> input; input -> get_overlaps;
    ins_position -> get_overlaps; get_overlaps -> overlaps; 
    overlaps -> create_primer; create_primer -> primers;
    primers -> report_best_primers; report_best_primers -> report
    
    subgraph cluster_ga {
      primers -> melt_temp; primers -> hairpin_prob;
      hairpin_prob -> primer_score; melt_temp -> primer_score;
      primer_score -> score; score -> rank_primers; 
      rank_primers -> mutate_primer; mutate_primer -> primers;
      label = 'Genetic algorithm'
    }
    
  }
")

```

## 03/09/2018

### Melting temperature calculation with MELTING tool

Today I am learning how to use the [MELTING](https://www.ebi.ac.uk/biomodels/tools/melting/) tool to calculate the melting temperature of primers. Accoring to the documenation, the following options are mandatory:

```
Mandatory options :

-S [sequence]
	Nucleic acid sequence, mandatory. The sens of this sequence must be 5'-3'.


-C [complementary sequence]
	Nucleic acid complementary sequence, mandatory only if there is inosine bases 
	or azobenznes in the sequence entered with the opton -S. The sens of this 
	sequence must be 3'-5''.

-E [agent1=concentration1:agent2=concentration2]
	Different agent concentrations in the solution. The agents can be cations 
	(Na, K, Tris, Mg for Na+, K+, Tris+ and Mg2+), dNTP or other agents 
	(DMSO, formamide). The concentrations must be in Mol/L but there are some 
	exceptions : DMSO is a percentage, formamide is a percentage if the method 
	lincorr is chosen and in Mol/L if the method bla96 is chosen. At least one 
	cation concentration is mandatory, the other agents are optional. See the 
	documentation for the concentration limits. It depends on the used correction.

-P [nucleotide concentration]
	Concentration in mol/L of the nucleic acid strand in excess, mandatory.

-H [hybridization]
	Type of hybridization, mandatory. Four types of hybridization are allowed: 
	dnadna (DNA duplex), rnarna (RNA duplex), dnarna or rnadna (hybrid DNA/RNA) 
	and mrnarna or rnamrna (2-o-methyl RNA/ RNA). The type of hybridization 
	defines the kind of the sequence and its complementary. 
		Ex : dnarna = the sequence (entered with the option -S) is a DNA sequence 
		and its complementary (entered with the option -C) is a RNA sequence.
		Ex : rnadna = the sequence (entered with the option -S) is a RNA sequence 
		and its complementary (entered with the option -C) is a DNA sequence  
```

We can use the following command to calculate the melting temperature of a
DNA-DNA hybridization:

```{bash}
/Users/pedro_work/MELTING5.1.1/executable/melting -S ATGGTGAGCAAGGGC -H dnadna 
-P 1e-7 -E Mg=1
```


### Integrating MELTING and R

To test the MELTING tool, I am going to use the `lambdaPrimeR` test primer 
sequences. The test primers are designed using the GFP gene sequence as target
and the pUC19 plasmid sequence as template. The insertion coordinate is 1500. 

```{r create-test-primers}
#Input sequences:
target <- system.file('extdata', 'GFP sequence.fasta', package = 'lambdaPrimeR')
template <- system.file('extdata', 'puc19.fasta', package = 'lambdaPrimeR')
inputs <- read_sequences(target, input_type = 'target')
inputs <- read_sequences(template, input_df = inputs, input_type = 'template')

#get sequence overlaps:
overlaps <- get_overlaps(inputs, 1500)
primers <- create_primer_pair(overlaps)
```

```{r pimers-object}
primers
```

Let's use the forward primer to test if we can use R to call MELTING to calculate
the melting temperature fr the annealing reagions of the primer, and return the
value back to R. The idea for this function came from [here](https://darrenjw.wordpress.com/2011/01/01/calling-java-code-from-r/).

```{r fun-melt-temperature}
primer <- toupper(primers$seq[primers$id == 'forward'])
melt_temperature <- function(sequence, template_conc, ion_conc) {
  melting_path <- "/Users/pedro_work/MELTING5.1.1/executable/melting"
  melting_command <- paste(melting_path, '-S', sequence, '-H dnadna', '-P',
                           template_conc, '-E', ion_conc)
  system(melting_command, intern = T)
}

melt_temp_test <- melt_temperature(primer, 1e-07, 'Mg=1')
```

```{r melt-temp-output}
melt_temp_test
```

## 03/10/18

### Updating `melt_temperature` function to parse `melting` command output

```{r fun-melt-temperature-update}
melt_temperature <- function(sequence, template_conc, ion_conc) {
  melting_path <- "/Users/pedro_work/MELTING5.1.1/executable/melting"
  melting_command <- paste(melting_path, '-S', sequence, '-H dnadna', '-P',
                           template_conc, '-E', ion_conc)
  out <- system(melting_command, intern = T)
  
  #Creting melting temperature dataframe:
  melt_temp <- tibble(raw = out[5]) %>%
    mutate(
      primer = sequence,
      tm = as.numeric(str_extract(raw, '\\d+\\.\\d+'))
    ) %>%
    select(-raw)
}

melt_temp <- melt_temperature(primer, template_conc = 1e-7, ion_conc = 'Mg=1')
```

```{r melt-temp-output-update}
melt_temp
```


