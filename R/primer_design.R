##############
#Primer design
##############

#' Extract target or vector-annealing regions from Template sequences. 
#'
#' @param template 
#' @param position 
#' @param min_length 
#' @param max_length 
#' @param ... 
#'
#' @return
#' @export
#'
#' @examples
setGeneric("get_annealing_regions", 
 function(template, position = NULL, min_length = NULL, max_length = NULL, ...) {
   standardGeneric("get_annealing_regions")
})

setMethod("get_annealing_regions", 
  signature = "Target",
  function(template, min_length = NULL, max_length = NULL) {
    #Using minimum allowed length as the length of the annealing region; 
    #otherwise use the default of 15 bp.
    length <- ifelse(is.null(min_length), 15, min_length)
    
    #Saving sequence slot from template class in a variable:
    seq <- template$seq
    seq_length <- template$length
    
    #When extracting the annealing regions from the target sequence, we need to 
    #get the 5' and 3' ends of the gene sequence:
    #Extracting overlaps
    target_annealing_left <- substr(seq, 1, length)
    target_annealing_right <- substr(seq, (seq_length-length), seq_length)
    
    #Adding annealing region info to target object:
    template$target_anneal_min_length <- min_length
    template$target_anneal_max_length <- max_length
    template$target_anneal_left_beg <- 1
    template$target_anneal_left_end <- length
    template$target_anneal_right_beg <- seq_length - length
    template$target_anneal_right_end <- seq_length
    template$target_anneal_left_seq <- target_annealing_left
    template$target_anneal_right_seq <- target_annealing_right

    return(template)
  }
)

setMethod("get_annealing_regions", 
          signature = "Vector",
          function(template, position = NULL, min_length = NULL, max_length = NULL) {
            #Using minimum allowed length as the length of the annealing region; 
            #otherwise use the default of 15 bp.
            length <- ifelse(is.null(min_length), 15, min_length)
            
            #Saving sequence slot from template class in a variable:
            seq <- template$seq
            seq_length <- template$length
            
            #When extracting the annealing regions from the target sequence, we need to 
            #get the 5' and 3' ends of the gene sequence:
            #Extracting overlaps
            vector_annealing_left <- substr(seq, (position-length), position)
            vector_annealing_right <- substr(seq, (position+1), (position+length+1))
            
            #Adding annealing region info to target object:
            template$vector_anneal_min_length <- min_length
            template$vector_anneal_max_length <- max_length
            template$vector_anneal_left_beg <- position - length
            template$vector_anneal_left_end <- position
            template$vector_anneal_right_beg <- position + 1
            template$vector_anneal_right_end <- position + length + 1
            template$vector_anneal_left_seq <- vector_annealing_left
            template$vector_anneal_right_seq <- vector_annealing_right
            
            return(template)
          }
)

# add_overlaps <- function(overlap_df) {
#   cols <- colnames(overlap_df)
# }

#' Extract overlaps from input sequences.
#'
#' @param sequence_inputs A dataframe containing the target and template input
#' sequences, generated by \code{read_sequences}.
#' @param position Numeric value indicating the insertion coordinate
#' @param length Length of the overlaping region to be extract from the input
#' sequences. Defaults to different values depending on the value of \code{type}:
#' 
#' \itemize{
#'   \item \code{type} = 'template' => \code{length} = 20
#'   \item \code{type} = 'target' => \code{length} = 15
#' }
#'
#' @return A dataframe containing the overlap sequence and orientation for each
#' input type. 
#' 
#' @export
#' @keywords internal
#'
get_overlaps <- function(sequence_inputs, position=NULL, length=NULL) {
  #Initialize empty overlap object
  overlaps <- tibble(
    id = character(),
    type = character(),
    origin = character(),
    seq = character()
  )
  
  #Function to find overlaps on each input type:
  find_overlaps <- function(data) {
    #Checking what type of input was passed:
    if(data$type == 'template') {
      #Using default overlap length of 20 if not provided:
      overlap_length <- ifelse(is.null(length), 20, length)
      #Extracting overlaps
      overlap_left <- substr(data$seq, (position-overlap_length), position)
      overlap_right <- substr(data$seq, (position+1), (overlap_length+position+1))
      #Populating overlap object:
      overlaps <- overlaps %>%
        add_row(id = 'left', type = 'overlap', origin = 'template', seq = overlap_left) %>%
        add_row(id = 'right', type = 'overlap', origin = 'template', seq = overlap_right)
    } else {
      #Using default overlap length of 15 if not provided:
      overlap_length <- ifelse(is.null(length), 15, length)
      #Extracting overlaps
      overlap_left <- substr(data$seq, 1, overlap_length)
      overlap_right <- substr(data$seq, data$length-overlap_length, data$length)
      #Populating overlap object:
      overlaps <- overlaps %>%
        add_row(id = 'left', type = 'overlap', origin = 'target', seq = overlap_left) %>%
        add_row(id = 'right', type = 'overlap', origin = 'target', seq = overlap_right)
    }
  }
  
  #Extracting overlaps
  sequence_inputs %>%
    group_by(type) %>%
    do(find_overlaps(.)) %>%
    ungroup()
}


#' Design primer pair from overlaps.
#'
#' This function uses the overlap information in the \code{overlaps} object
#' to design a primer pair by concatenating the overlap sequences in the
#' correct order (see Details).
#' 
#' In order to design the primers for the first PCR step of LambdaPCR, where we
#' add template-overlaping flanking regions to our target gene sequence, 
#' we have to use the following rules:
#'
#' \itemize{
#'   \item \strong{Forward primer:} left overlap + target left overlap, 
#'   5'-3' orientation
#'   \item \strong{Reverse primer:} complement of target right overlap + 
#'   complement of template right overlap,  5'-3' orientation
#' }
#'
#' @param overlaps A dataframe containing the overlap information for both input
#' types. The \code{overlaps} object is created by \code{get_overlaps}.
#'
#' 
#' @return A dataframe containing the forward and reverse primer sequences.
#' @export
create_primer_pair <- function(overlaps) {
  primers <- overlaps %>%
    #Add columns with overlap seqs:
    spread(origin, seq) %>%
    select(-type) %>%
    mutate(
      #We need to get the reverse complement of the right-oriented overlaps
      #and merge the overlaps sequence to get the final primer seqs:
      seq = case_when(
        id == 'left' ~ paste(tolower(template), 
                             target, 
                             sep = ''),
        id == 'right' ~ paste(tolower(reverse_complement(template)), 
                              reverse_complement(target), 
                              sep = ''
        )
      )
    ) %>%
    #changing id to primer orientation
    mutate(id = case_when(
      id == 'left' ~ gsub('left', 'forward', id),
      id == 'right' ~ gsub('right', 'reverse', id)
    )) %>%
    mutate(type = 'primer') %>%
    #extracting template and target annealing sequences
    mutate(temp = str_replace(seq, '([[:upper:]])', ',\\1')) %>%
    separate(temp, into = c('template_annealing_seq', 'target_annealing_seq'),
             sep = ',') %>%
    select(-target, -template)
    
}