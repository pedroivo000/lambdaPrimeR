##############
#Primer design
##############

#' Extract overlaps from input sequences.
#'
#' @param sequence_inputs A dataframe containing the target and template input
#' sequences, generated by \code{read_sequences}.
#' @param position Numeric value indicating the insertion coordinate
#' @param length Length of the overlaping region to be extract from the input
#' sequences. Defaults to different values depending on the value of \code{type}:
#' 
#' \itemize{
#'   \item \code{type} = 'template' => \code{length} = 20
#'   \item \code{type} = 'target' => \code{length} = 15
#' }
#'
#' @return A dataframe containing the overlap sequence and orientation for each
#' input type. 
#' 
#' @keywords internal
#'
get_overlaps <- function(sequence_inputs, position=NULL, length=NULL) {
  #Initialize empty overlap object
  overlaps <- tibble(
    id = character(),
    type = character(),
    origin = character(),
    seq = character()
  )
  
  #Function to find overlaps on each input type:
  find_overlaps <- function(data) {
    #Checking what type of input was passed:
    if(data$type == 'template') {
      #Using default overlap length of 20 if not provided:
      overlap_length <- ifelse(is.null(length), 20, length)
      #Extracting overlaps
      overlap_left <- substr(data$seq, (position-overlap_length), position)
      overlap_right <- substr(data$seq, (position+1), (overlap_length+position+1))
      #Populating overlap object:
      overlaps <- overlaps %>%
        add_row(id = 'left', type = 'overlap', origin = 'template', seq = overlap_left) %>%
        add_row(id = 'right', type = 'overlap', origin = 'template', seq = overlap_right)
    } else {
      #Using default overlap length of 15 if not provided:
      overlap_length <- ifelse(is.null(length), 15, length)
      #Extracting overlaps
      overlap_left <- substr(data$seq, 1, overlap_length)
      overlap_right <- substr(data$seq, data$length-overlap_length, data$length)
      #Populating overlap object:
      overlaps <- overlaps %>%
        add_row(id = 'left', type = 'overlap', origin = 'target', seq = overlap_left) %>%
        add_row(id = 'right', type = 'overlap', origin = 'target', seq = overlap_right)
    }
  }
  
  #Extracting overlaps
  sequence_inputs %>%
    group_by(type) %>%
    do(find_overlaps(.)) %>%
    ungroup()
}


#' Design primer pair from overlaps.
#'
#' This function uses the overlap information in the \code{overlaps} object
#' to design a primer pair by concatenating the overlap sequences in the
#' correct order (see Details).
#' 
#' In order to design the primers for the first PCR step of LambdaPCR, where we
#' add template-overlaping flanking regions to our target gene sequence, 
#' we have to use the following rules:
#'
#' \itemize{
#'   \item \strong{Forward primer:} left overlap + target left overlap, 
#'   5'-3' orientation
#'   \item \strong{Reverse primer:} complement of target right overlap + 
#'   complement of template right overlap,  5'-3' orientation
#' }
#'
#' @param overlaps A dataframe containing the overlap information for both input
#' types. The \code{overlaps} object is created by \code{get_overlaps}.
#'
#' @return A dataframe containing the forward and reverse primer sequences.
create_primer_pair <- function(overlaps) {
  primers <- overlaps %>%
    #Add columns with overlap seqs:
    spread(origin, seq) %>%
    select(-type) %>%
    mutate(
      #We need to get the reverse complement of the right-oriented overlaps
      #and merge the overlaps sequence to get the final primer seqs:
      seq = case_when(
        id == 'left' ~ paste(tolower(template), 
                             target, 
                             sep = ''),
        id == 'right' ~ paste(tolower(reverse_complement(template)), 
                              reverse_complement(target), 
                              sep = ''
        )
      )
    ) %>%
    mutate(id = case_when(
      id == 'left' ~ gsub('left', 'forward', id),
      id == 'right' ~ gsub('right', 'reverse', id)
    )) %>%
    mutate(type = 'primer') %>%
    select(-target, -template)
}


#' Calculate primer melting temperature. 
#'
#' @param sequence A string corresponding to the primer sequence.
#' @param template_conc A numeric value corresponding to the DNA template 
#' concentration. Defauts to $10^-4$ M. 
#' @param ion_conc A string corresponding to the concentration of ion. See 
#' MELTING documentation for details. 
#'
#' @return A dataframe containing the primer sequence and the calculated melting
#' temperature \code{tm}.
#' @export
#'
#' @examples
melt_temperature <- function(sequence, template_conc, ion_conc) {
  melting_path <- "/Users/pedro_work/MELTING5.1.1/executable/melting"
  melting_command <- paste(melting_path, '-S', sequence, '-H dnadna', '-P',
                           template_conc, '-E', ion_conc)
  out <- system(melting_command, intern = T)
  
  #Creting melting temperature dataframe:
  melt_temp <- tibble(raw = out[5]) %>%
    mutate(
      primer = sequence,
      tm = as.numeric(str_extract(raw, '\\d+\\.\\d+'))
    ) %>%
    select(-raw)
  
  melt_temp
}